print("ðŸ“Š Generating rolling forecast plots for each sitting month...")

month_names_dict = {
    1: 'Jan', 2: 'Feb', 3: 'Mar', 4: 'Apr', 5: 'May', 6: 'Jun',
    7: 'Jul', 8: 'Aug', 9: 'Sep', 10: 'Oct', 11: 'Nov', 12: 'Dec'
}

# Iterate through each sitting_month from 1 (January) to 11 (November)
for sitting_month in range(1, 12):
    plot_data_current_view = []
    sitting_month_name = month_names_dict[sitting_month]

    # Iterate through each month m from 1 to 12 (January to December)
    for m in range(1, 13):
        month_name = month_names_dict[m]
        current_actual = np.nan
        current_predicted = np.nan

        if m < sitting_month:
            # Retrieve actual revenue for months before the sitting month
            actual_row = test_df[(test_df['year'] == 2025) & (test_df['month_num'] == m) & (test_df['actual_revenue'].notna())]
            if not actual_row.empty:
                current_actual = actual_row['actual_revenue'].values[0]
        else:
            # Retrieve predictions from the current sitting month onwards
            prediction_row = monthly_results[
                (monthly_results['start_month'] == sitting_month) &
                (monthly_results['forecast_month'] == m)
            ]
            if not prediction_row.empty:
                current_predicted = prediction_row['predicted'].values[0]
                if not prediction_row['is_imputed'].values[0]:
                    # If actual value exists for this forecast month (not imputed)
                    current_actual = prediction_row['actual'].values[0]

        plot_data_current_view.append({'month_name': month_name, 'actual': current_actual, 'predicted': current_predicted})

    df_plot = pd.DataFrame(plot_data_current_view)

    plt.figure(figsize=(14, 7))
    sns.lineplot(x='month_name', y='actual', data=df_plot, marker='o', label='Actual Revenue', color='blue')
    sns.lineplot(x='month_name', y='predicted', data=df_plot, marker='x', linestyle='--', label='Predicted Revenue', color='red')

    plt.title(f'2025 Year-End Forecast View from Month {sitting_month_name}')
    plt.xlabel('Month')
    plt.ylabel('Revenue')
    plt.ticklabel_format(style='plain', axis='y') # Prevent scientific notation on y-axis
    plt.grid(True, linestyle='--', alpha=0.7)
    plt.legend()
    plt.tight_layout()
    plt.show()

print("âœ… All rolling forecast plots generated!")



import numpy as np
import pandas as pd

def create_local_ewm_features_for_target_month(
    sitting_month_data,
    target_month,
    full_df,
    features,
    month_col='month_num',
    ewm_span=6,
    window_size=6
):
    """
    Create feature row for ONE target month using LOCAL EWM logic:
    - Uses current snapshot + last (window_size - 1) rows
    - Computes EWM(span=ewm_span) on that local window
    - Propagates features into the future
    """

    # ---- Sitting snapshot ----
    base_row = sitting_month_data.iloc[0].copy()
    sitting_month = int(base_row[month_col])

    step = target_month - sitting_month
    if step < 0:
        raise ValueError("Target month cannot be before sitting month")

    # ---- Select local window: current + last 5 rows ----
    local_window_df = (
        full_df[full_df[month_col] <= sitting_month]
        .sort_values(month_col)
        .tail(window_size)
    )

    # ---- Auto-detect numeric feature columns ----
    numeric_cols = [
        c for c in features
        if c != month_col and pd.api.types.is_numeric_dtype(full_df[c])
    ]

    # ---- Compute LOCAL EWM anchor per feature ----
    local_ewm_anchor = {}

    for col in numeric_cols:
        series = local_window_df[col].dropna()

        if len(series) >= 2:
            local_ewm_anchor[col] = (
                series.ewm(span=ewm_span, adjust=False).mean().iloc[-1]
            )
        elif len(series) == 1:
            local_ewm_anchor[col] = series.iloc[0]
        else:
            local_ewm_anchor[col] = base_row[col]

    # ---- Create target-month feature row ----
    new_row = base_row.copy()
    new_row[month_col] = target_month

    decay = np.exp(-step / ewm_span)

    for col in numeric_cols:
        snapshot_val = base_row[col]
        ewm_val = local_ewm_anchor[col]

        # Smooth propagation
        new_row[col] = snapshot_val * decay + ewm_val * (1 - decay)

    return pd.DataFrame([new_row])[features]

